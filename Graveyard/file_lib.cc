/************************************************************************/
/*     File: file_lib.cc                                                	*/ 
/*     Date: August 1996                                                */
/*       By: Eric Zbinden					  	*/
/*      For: NASA Ames Research Center, Intelligent Mechanisms Group  	*/
/* Function: Read, write & initialize, Files, buffers & struct		*/
/************************************************************************/

#include <stdio.h>
#include <math.h>
#include <limits.h>
#include <fstream>
#include <sstream>
#include <vector>
#include <boost/version.hpp>
#include <boost/program_options.hpp>
namespace po = boost::program_options;

#include "file_lib.h"
#include "MOC/Metadata.h"

#include <vw/Core/Exception.h>
#include <vw/Image/ImageView.h>
#include <vw/FileIO.h>

using namespace std; /* C standard library */
using namespace vw;
using namespace vw::camera;

void write_orbital_reference_model(std::string filename, 
                                   vw::camera::CameraModel const& cam1, 
                                   vw::camera::CameraModel const& cam2) {
  FILE *outflow = stdout;
  const char* resource_path = "/irg/projects/MOC/resources/OrbitViz";

  printf("Writing Orbital Visualization VRML file to disk.\n");
  
  /* open output file */
  if((outflow = fopen (filename.c_str(), "w" )) == 0) { 
    throw IOErr() << "An error occured while opening the Orbital Reference VRML file for writing.";
  }

  fprintf(outflow, "#VRML V1.0 ascii\n#\n");              

  fprintf(outflow, "# File generated by the NASA Ames Stereo Pipeline\n#\n");
  fprintf(outflow, "# Michael Broxton and Larry Edwards\n");
  fprintf(outflow, "# Intelligent Robotics Group, NASA Ames Research Center\n\n");
  fprintf (outflow, "Separator {\n");

  fprintf (outflow, "  #Mars coordinate system\n");
  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 4000 4000 4000 }\n");
  fprintf (outflow, "      File { name \"%s/refFrame.wrl\" }\n", 
	            resource_path);
  fprintf (outflow, "    } Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 0.51 0.51 0.51 }\n");
  fprintf (outflow, "      File { name \"%s/Mars.wrl\" }\n", resource_path);
  fprintf (outflow, "    }\n  }\n\n");

  /* 
   * First camera frame
   */
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  fprintf(outflow, "  # Camera 1 coordinate system at t0\n");
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  Vector3 pos1 = cam1.camera_center(Vector2(0,0));    // Camera position 
  Quaternion<double> quat1 = cam1.camera_pose(Vector2(0,0)); // Camera Pose
  Matrix<double> rot1(4,4);
  rot1.set_identity();
  quat1.rotation_matrix(rot1);
  std::cout << "rot1: " << rot1 << "\n";

  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Translation { translation %f %f %f }\n", 
	   pos1(0)/1000.0, pos1(1)/1000.0, pos1(2)/1000.0);
  fprintf (outflow, "    MatrixTransform { matrix\n");
  fprintf (outflow, "      %f %f %f %f\n", rot1(0,0), rot1(0,1), rot1(0,2), rot1(0,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(1,0), rot1(1,1), rot1(1,2), rot1(1,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(2,0), rot1(2,1), rot1(2,2), rot1(2,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(3,0), rot1(3,1), rot1(3,2), rot1(3,3));
  fprintf (outflow, "    }\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 1000 1000 1000 }\n");
  fprintf (outflow, "      File  { name \"%s/refFrame.wrl\" }\n", 
                    resource_path);
  fprintf (outflow, "    }\n  }\n");


  /* 
   * Second camera frame
   */
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  fprintf(outflow, "  # Camera 2 coordinate system at t0\n");
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  Vector3 pos2 = cam2.camera_center(Vector2(0,0));    /* Camera position */
  vw::Quaternion<double> quat2 = cam2.camera_pose(Vector2(0,0)); /* Camera pose */
  vw::Matrix<double> rot2(4,4);
  rot2.set_identity();
  quat2.rotation_matrix(rot2);
  std::cout << "rot2: " << rot2 << "\n";

  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Translation { translation %f %f %f } \n", 
           pos2(0)/1000.0, pos2(1)/1000.0, pos2(2)/1000.0);
  fprintf (outflow, "    MatrixTransform { matrix\n");
  fprintf (outflow, "      %f %f %f %f\n", rot2(0,0), rot2(0,1), rot2(0,2), rot2(0,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(1,0), rot2(1,1), rot2(1,2), rot2(1,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(2,0), rot2(2,1), rot2(2,2), rot2(2,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(3,0), rot2(3,1), rot2(3,2), rot2(3,3));
  fprintf (outflow, "    }\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 1000 1000 1000 }\n");
  fprintf (outflow, "      File  { name \"%s/refFrame.wrl\" }\n", 
                    resource_path);
  fprintf (outflow, "    }\n  }\n");
  fprintf (outflow, "}\n\n");
  
  printf("\t%s written successfully\n\n", filename.c_str());
  fclose(outflow);
}

/************************************************************************/
/*									*/
/*	             	     STRUCTURES					*/
/*									*/
/************************************************************************/

enum OptionType {
  OPTION_TYPE_INT,
  OPTION_TYPE_FLOAT,
  OPTION_TYPE_DOUBLE
};

// Determine type of option.
OptionType option_type(po::option_description& d) {
  OptionType type = OPTION_TYPE_INT;
  
  boost::shared_ptr<const po::typed_value<int> > intp = boost::dynamic_pointer_cast<const po::typed_value<int> >(d.semantic());
  boost::shared_ptr<const po::typed_value<float> > floatp = boost::dynamic_pointer_cast<const po::typed_value<float> >(d.semantic());
  boost::shared_ptr<const po::typed_value<double> > doublep = boost::dynamic_pointer_cast<const po::typed_value<double> >(d.semantic());
  
  if(intp.get())
    type = OPTION_TYPE_INT;
  else if(floatp.get())
    type = OPTION_TYPE_FLOAT;
  else if(doublep.get())
    type = OPTION_TYPE_DOUBLE;
  else {
    std::cerr << "Error: Option " << d.long_name() << " is not a supported type." << std::endl;
    exit(EXIT_FAILURE);
  }
  if((intp.get() ? 1 : 0) + (floatp.get() ? 1 : 0) + (doublep.get() ? 1 : 0) > 1) {
    std::cerr << "Error: Option " << d.long_name() << " is of more than one supported type." << std::endl;
    exit(EXIT_FAILURE);
  }
  
  return type;
}

// Build po::options_description desc and associate it with dft and todo.
void associate_dft_struct(DFT_F *dft, po::options_description *desc) {

#define ASSOC_INT(X,Y,V,D)             desc->add_options()(X, po::value<int>(&(dft->Y))->default_value(V), D)
#define ASSOC_FLOAT(X,Y,V,D)           desc->add_options()(X, po::value<float>(&(dft->Y))->default_value(V), D)
#define ASSOC_DOUBLE(X,Y,V,D)          desc->add_options()(X, po::value<double>(&(dft->Y))->default_value(V), D)

  // Preprocessing options
  ASSOC_INT("DO_EPIPOLAR_ALIGNMENT", epipolar_alignment, 0, "Align images using epipolar constraints");
  ASSOC_INT("DO_KEYPOINT_ALIGNMENT", keypoint_alignment, 1, "Align images using the keypoint alignment method");
  ASSOC_INT("KEYPOINT_ALIGN_SUBSAMPLING", keypoint_align_subsampling, 1, "Image sub-sampling factor for keypoint alignment.");

  // Correlation Options
  ASSOC_INT("DO_SLOG", slog, 0, "perform an slog (relpace the emboss)");
  ASSOC_INT("DO_LOG", log, 0, "perform a log (laplacian of gaussian)");
  ASSOC_FLOAT("SLOG_KERNEL_WIDTH", slogW, 1.5, "SIGMA for the gaussian blure in LOG and SLOG");
  ASSOC_INT("H_KERNEL", h_kern, 0, "kernel width");
  ASSOC_INT("V_KERNEL", v_kern, 0, "kernel height");  
  ASSOC_INT("H_CORR_MAX", h_corr_max, 0, "correlation window size max x");
  ASSOC_INT("H_CORR_MIN", h_corr_min, 0, "correlation window size min x");
  ASSOC_INT("V_CORR_MIN", v_corr_min, 0, "correlation window size min y");
  ASSOC_INT("V_CORR_MAX", v_corr_max, 0, "correlation window size max y");
  ASSOC_INT("DO_H_SUBPIXEL", do_h_subpixel, 1, "Do vertical subpixel interpolation.");
  ASSOC_INT("DO_V_SUBPIXEL", do_v_subpixel, 1, "Do horizontal subpixel interpolation.");
  ASSOC_FLOAT("XCORR_TRESHOLD", xcorr_treshold, 2.0, "");
  ASSOC_FLOAT("CORRSCORE_REJECTION_THRESHOLD", corrscore_rejection_treshold, 1.0, "");

  // Filtering Options
  ASSOC_INT("RM_H_HALF_KERN", rm_h_half_kern, 0, "low conf pixel removal kernel half size");
  ASSOC_INT("RM_V_HALF_KERN", rm_v_half_kern, 0, "");
  ASSOC_INT("RM_MIN_MATCHES", rm_min_matches, 0, "min # of pxls to be matched to keep pxl");
  ASSOC_INT("RM_TRESHOLD", rm_treshold, 1, "rm_treshold > disp[n]-disp[m] pixels are not matching");
  ASSOC_INT("RM_CLEANUP_PASSES", rm_cleanup_passes, 1, "number of passes for cleanup during the post-processing phase");
  ASSOC_INT("FILL_HOLES_NURBS", fill_holes_NURBS, 0, "fill holes using Larry's NURBS code");

  // Triangulation Options
  ASSOC_FLOAT("NEAR_UNIVERSE_RADIUS", near_universe_radius, 0.0, "radius of inner boundary of universe [m]");
  ASSOC_FLOAT("FAR_UNIVERSE_RADIUS", far_universe_radius, 0.0, "radius of outer boundary of universe [m]");

#undef ASSOC_INT
#undef ASSOC_FLOAT
#undef ASSOC_DOUBLE

}

/************************************************************************/
/*	             initialize Header Structure            		*/
/************************************************************************/

void init_dft_struct(DFT_F *dft) {
  po::options_description desc;
  po::variables_map vm;
  int argc = 1;
  char* argv[1];
  argv[0] = "dummyprogname";
  associate_dft_struct(dft, &desc);
  po::store(po::parse_command_line(argc, argv, desc), vm);
  po::notify(vm);
}

/************************************************************************/
/*									*/
/*		          read stereo.default				*/
/*									*/
/************************************************************************/

// Determine whether the given character is a space character.
inline bool is_space_char(int c) {
  return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

// Read from stream until (but not including) the next non-space character.
inline void ignorespace(std::istream& s) {
  int c;
  if(s.eof())
    return;
  while((c = s.get()) != EOF && is_space_char(c));
  if(c != EOF)
    s.unget();
}

// Read from stream until (but not including) the beginning of the next line.
inline void ignoreline(std::istream& s) {
  int c;
  if(s.eof())
    return;
  while((c = s.get()) != EOF && c != '\n');
}

// Read from stream until (but not including) the next space character. Ignores space characters at beginning.
inline void getword(std::istream& s, std::string& str) {
  int c;
  str.clear();
  ignorespace(s);
  if(s.eof())
    return;
  while((c = s.get()) != EOF && !is_space_char(c))
    str.push_back(c);
  if(c != EOF)
    s.unget();
}

// Read default file.
void read_default_file(DFT_F *dft, std::string const& filename) {
  po::options_description desc;
  po::variables_map vm;
  associate_dft_struct(dft, &desc);

  std::ifstream fp(filename.c_str());
  if(!fp) {
    std::cerr << "Error: cannot open stereo default file: " << filename << "\n";
    exit(EXIT_FAILURE);
  }

  std::cout << "Reading stereo default file." << std::endl;
  std::string name, value, line;
  int c;

  while(!fp.eof()) {
    ignorespace(fp);
    if(!fp.eof() && (c = fp.peek()) != '#') {
      std::istringstream ss; //NOTE: cannot move this up with other variable declarations because then calling store(parse_config_file()) multiple times does not work as expected
      getword(fp, name);
      if(name == "END")
        break;
      // special case for UNIVERSE_RADIUS, which is an alias for FAR_UNIVERSE_RADIUS
      if(name == "UNIVERSE_RADIUS")
        name = "FAR_UNIVERSE_RADIUS";
      getword(fp, value);
      line = name.append(" = ").append(value);
      ss.str(line);
      //NOTE: Unlike the command-line options parsing facility, the config-file parsing facility does not allow us to specify that it should ignore unknown options, so this call chokes on unknown config options.
      po::store(po::parse_config_file(ss, desc), vm);
    }
    ignoreline(fp);
  }
  
  po::notify(vm);
  printf(" *************************************************************\n");
  printf("Stereo Default File loaded successfully\n");
  fp.close();
}

/************************************************************************/
/*									*/
/*		          write stereo.default				*/
/*									*/
/************************************************************************/

// // Write config file. Analogous to po::parse_config_file().
// void write_config_file(std::basic_ostream<char>& s, po::options_description& desc) {
//   OptionType type;
//   std::vector<AugmentingDescription>::iterator pi;
//   std::string name, value, description;
//   void* ptr;
//   bool first = true;

//   //NOTE: instead of iterating over adesc, we could ask desc for the po::option_description's; however, the interface for getting this information changed between boost versions 1.32.0 and 1.33.0 (there is no other 1.32.x--these are consecutive releases). Version 1.32.0 (the first release of boost with program_options) has a function keys() that returns a std::set of option names (in alphabetical order, not in the original option order), which you can then find(name). Versions 1.33.0 and up instead have a function options() that directly returns a vector of (boost::shared_ptr's to) po::option_description's (presumably in the original option order given above), although it also supports find(name, approx). Since we're already using adesc, we might as well take advantage of it to (partially--note that find() has changed) avoid this unstable interface and to always get the options in the original order.
//   for(pi = adesc.begin(); pi != adesc.end(); pi++) {
// #if BOOST_VERSION == 103200
//     po::option_description d = desc.find((*pi).name);
// #else
//     po::option_description d = desc.find((*pi).name, false);
// #endif
//     name = d.long_name();
//     if(name.empty()) {
//       std::string origname((*pi).name);
//       std::cerr << "Error: Option " << origname << " must have a long name for a config file." << std::endl;
//       exit(EXIT_FAILURE);
//     }
//     description = d.description();
//     type = option_type(d);
//     //NOTE: unfortunately, we cannot get the store-to pointer back out of d.semantic() (this is a "po::value()"/po::signed_value()), so we use adesc
//     ptr = (*pi).data;
//     // Finally, we output to the file
//     s << std::endl;
//     if(!description.empty())
//       s << "# " << description << std::endl;
//     s << name;
//     s << "\t";

//     switch(type) {
//     case OPTION_TYPE_INT:
//       s << *((int*)ptr) << std::endl;
//       break;
//     case OPTION_TYPE_FLOAT:
//       s << fixed << *((float*)ptr) << std::endl;
//       break;
//     case OPTION_TYPE_DOUBLE:
//       s << fixed << *((double*)ptr) << std::endl;
//       break;
//     default:
//       std::cerr << "Unexpected type!" << std::endl;
//       break;
//     }
//     first = false;
//   }

//   if(!first)
//     s << std::endl;
// #endif
// }

// void write_default_file(DFT_F *dft, std::string const& filename) {
//   po::options_description desc;
//   std::vector<AugmentingDescription> adesc;

//   std::ofstream fp(filename.c_str());
//   if(!fp) {
//     std::cerr << "Error: cannot open stereo default file for writing: " << filename << "\n";
//     exit(EXIT_FAILURE);
//   }
//   associate_dft_struct(dft, &desc, &adesc);
//   write_config_file(fp, desc, adesc);
//   printf(" *************************************************************\n");
//   printf("Stereo Default File written successfully\n");
//   fp.close();
// }
