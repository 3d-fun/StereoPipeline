/************************************************************************/
/*     File: file_lib.cc                                                	*/ 
/*     Date: August 1996                                                */
/*       By: Eric Zbinden					  	*/
/*      For: NASA Ames Research Center, Intelligent Mechanisms Group  	*/
/* Function: Read, write & initialize, Files, buffers & struct		*/
/************************************************************************/

#define NAME_LENGTH 1024

#include <stdio.h>
#include <math.h>
#include <limits.h>
#include "file_lib.h"
#include "MOC/Metadata.h"

#include <vw/Core/Exception.h>
#include <vw/Image/ImageView.h>
#include <vw/FileIO.h>
#include <vw/Stereo/StereoModel.h>
using namespace std; /* C standard library */
using namespace vw::camera;
using namespace vw::stereo;

void write_orbital_reference_model(std::string filename, 
                                   vw::camera::CameraModel const& cam1, 
                                   vw::camera::CameraModel const& cam2) {
  FILE *outflow = stdout;
  const char* resource_path = "/irg/projects/MOC/resources/OrbitViz";

  printf("Writing Orbital Visualization VRML file to disk.\n");
  
  /* open output file */
  if((outflow = fopen (filename.c_str(), "w" )) == 0) { 
    throw IOErr() << "An error occured while opening the Orbital Reference VRML file for writing.";
  }

  fprintf(outflow, "#VRML V1.0 ascii\n#\n");              

  fprintf(outflow, "# File generated by the NASA Ames Stereo Pipeline\n#\n");
  fprintf(outflow, "# Michael Broxton and Larry Edwards\n");
  fprintf(outflow, "# Intelligent Robotics Group, NASA Ames Research Center\n\n");
  fprintf (outflow, "Separator {\n");

  fprintf (outflow, "  #Mars coordinate system\n");
  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 4000 4000 4000 }\n");
  fprintf (outflow, "      File { name \"%s/refFrame.wrl\" }\n", 
	            resource_path);
  fprintf (outflow, "    } Separator {\n");
  fprintf (outflow, "      File { name \"%s/Mars.wrl\" }\n", resource_path);
  fprintf (outflow, "    }\n  }\n\n");

  /* 
   * First camera frame
   */
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  fprintf(outflow, "  # Camera 1 coordinate system at t0\n");
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  Vector3 pos1 = cam1.camera_center(Vector2(0,0));    // Camera position 
  Quaternion<double> quat1 = cam1.camera_pose(Vector2(0,0)); // Camera Pose
  Matrix<double> rot1(4,4);
  rot1.set_identity();
  quat1.rotation_matrix(rot1);

  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Translation { translation %f %f %f }\n", 
	   pos1(0)/1000.0, pos1(1)/1000.0, pos1(2)/1000.0);
  fprintf (outflow, "    MatrixTransform { matrix\n");
  fprintf (outflow, "      %f %f %f %f\n", rot1(0,0), rot1(0,1), rot1(0,2), rot1(0,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(1,0), rot1(1,1), rot1(1,2), rot1(1,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(2,0), rot1(2,1), rot1(2,2), rot1(2,3));
  fprintf (outflow, "      %f %f %f %f\n", rot1(3,0), rot1(3,1), rot1(3,2), rot1(3,3));
  fprintf (outflow, "    }\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 1000 1000 1000 }\n");
  fprintf (outflow, "      File  { name \"%s/refFrame.wrl\" }\n", 
                    resource_path);
  fprintf (outflow, "    }\n  }\n");


  /* 
   * Second camera frame
   */
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  fprintf(outflow, "  # Camera 2 coordinate system at t0\n");
  fprintf(outflow, "  # ----------------------------------------------------------\n");
  Vector3 pos2 = cam2.camera_center(Vector2(0,0));    /* Camera position */
  vw::Quaternion<double> quat2 = cam2.camera_pose(Vector2(0,0)); /* Camera pose */
  vw::Matrix<double> rot2(4,4);
  rot2.set_identity();
  quat2.rotation_matrix(rot2);

  fprintf (outflow, "  Separator {\n");
  fprintf (outflow, "    Translation { translation %f %f %f } \n", 
           pos2(0)/1000.0, pos2(1)/1000.0, pos2(2)/1000.0);
  fprintf (outflow, "    MatrixTransform { matrix\n");
  fprintf (outflow, "      %f %f %f %f\n", rot2(0,0), rot2(0,1), rot2(0,2), rot2(0,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(1,0), rot2(1,1), rot2(1,2), rot2(1,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(2,0), rot2(2,1), rot2(2,2), rot2(2,3));
  fprintf (outflow, "      %f %f %f %f\n", rot2(3,0), rot2(3,1), rot2(3,2), rot2(3,3));
  fprintf (outflow, "    }\n");
  fprintf (outflow, "    Separator {\n");
  fprintf (outflow, "      Scale { scaleFactor 1000 1000 1000 }\n");
  fprintf (outflow, "      File  { name \"%s/refFrame.wrl\" }\n", 
                    resource_path);
  fprintf (outflow, "    }\n  }\n");
  fprintf (outflow, "}\n\n");
  
  printf("\t%s written successfully\n\n", filename.c_str());
  fclose(outflow);
}

/************************************************************************/
/*									*/
/*	             	     STRUCTURES					*/
/*									*/
/************************************************************************/

/************************************************************************/
/*	             initialize Header Structure            		*/
/************************************************************************/

void init_dft_struct(DFT_F *dft, TO_DO *todo) {
    
  todo->do_alignment = 1;       /* Do we do alignment at all? */
  todo->keypoint_alignment = 1; /* Align images using the keypoint alignment method */
  todo->ephemeris_alignment = 0;/* Align images using the ephemeris alignment method */
  todo->epipolar_alignment = 0; /* Align images using epipolar constraints */

  todo->format_size = 0;	/* format the size of the image */
  todo->slog = 0;		/* perform an slog (relpace the emboss) */
  todo->log = 0;		/* perform a log (laplacian of gaussian) */
  todo->eq_hist1 = 0;		/* do the first histogam equalisation */
  todo->emboss = 0;		/* do the emboss convolution */
  todo->eq_hist2 = 0;		/* do the second histogam equalisation */
  todo->autoSetCorrParam=0; /*uses pyramidal scheme to autom get search param*/
  todo->vert_cal = 0;		/* do the vertical calibration */
  todo->w_texture = 0;		/* write the pgm texture File */
  todo->w_preprocessed = 0;	/* write the preprocessed image file */
  todo->corr_1st_pass = 1;      /* do the correlation */
  todo->biDimCorr = 1;      	/* do a 2D correlation by default */
  todo->corr_clean_up = 0;	/* do n filtering pass to rm wrong matches */
  todo->w_debug_disp = 0;	/* write intermediate disp.pgm files */
  todo->w_disp_stp = 1;		/* write an stp file of the raw disp map */
  todo->w_disp_pgm = 0;		/* write an pgm file of the raw disp map */
  todo->w_raw_disparity_map = 0; //write raw unscaled disparity values
  todo->w_pgm_disparity_map = 0; //write a pgm file of disparity map unscaled
  todo->fill_v_holes = 0;	/* fill holes in dispmap with vert algorithm */
  todo->fill_h_holes = 0;	/* fill holes in dispmap with horz algorithm */
  todo->fill_holes_NURBS = 0;   /* fill holes using Larry's NURBS code */
  todo->extend_lr = 0;		/* extrapolate disp values (Left/Right) */
  todo->extend_tb = 0;		/* extrapolate disp values (Top/Bottom) */
  todo->smooth_disp = 0;	/* smooth the disp map */
  todo->w_filtered_disp_pgm = 0;/* write the filtered disp map in pgm */
  todo->smooth_range = 0;	/* do a smooth range on the range file */
  todo->dotcloud = 0;		/* build the dotcloud model */
  todo->local_level_transform = 0; /* coordinate transfrom: lander to 
				      local level to z-up, x-north frame */
  todo->w_dotcloud = 0;		/* write dotcloud file */
  todo->w_vicar_range_maps = 0;	/* write range maps in mvacs vicar format */
  todo->w_vicar_xyz_map = 0;	/* write xyz range map in vicar format */
  todo->w_disp_vicar = 0;	/* write disp map in vicar format */
  todo->alt_texture = 0;	/* create and write a texture f(altitude) */
  todo->mesh = 0;		/* do the mesh */
  todo->adaptative_meshing = 0;	/* do not do the adaptative meshing by dft */
  todo->nff_plain = 0;		/* save it as a plain model */
  todo->nff_txt = 0;		/* save it as a textured model */
  todo->double_sided = 0;	/* draw two sided polygons */
  todo->inventor = 0;		/* save it as an Inventor file */    
  todo->vrml = 0;		/* save it as an VRML file */    
  todo->write_dem = 0;		/* save it as a DEM file */
  todo->apply_mask = 1;		/* apply the mask by default */
  todo->w_mask = 0;		/* do not write the mask file by default */
  todo->w_extrapolation_mask = 0; /* do not write the extrapolation mask */

  dft->ephem_align_kernel_x = 150; /* x coordinate of the ephem. alignmnt kernel */
  dft->ephem_align_kernel_y = 150; /* y coordinate of the ephem. alignmnt kernel */
  dft->ephem_align_kernel_width = 40;  /* Width of the ephemeris alignment kernel */
  dft->ephem_align_kernel_height = 40; /* Height of the ephemeris alignment kernel */

  dft->h_kern = 0;		/* kernel width first pass */
  dft->v_kern = 0;		/* kernel height first pass*/
  dft->corr_margin = 0;	        /* extra margin for search window */
  dft->h_corr_max = 0;		/* correlation window size max x */
  dft->h_corr_min = 0;		/* correlation window size min x */
  dft->crop_x_min = 0;		/* cropping coordonate */
  dft->crop_x_max = 0;
  dft->crop_y_min = 0;
  dft->crop_y_max = 0;
  dft->v_corr_min = 0;		/* automatic img alignment parameters */
  dft->v_corr_max = 0;		/* min max vertical picture shift interval */
  dft->autoSetVCorrParam=0;   	/* goes with autoSetCorrParam */
  /* camera parameters */
  dft->useCAHV = 0;
  dft->baseline = 0.0;		/* distance between the cameras */
  dft->tilt_pivot_offset = 0.0;	/* vert dist btwn optical axis and tilt axis */
  dft->camera_offset = 0.0;	/* horz dist btwn cam nodal pt and tilt axis */
  dft->x_pivot_offset = 0.0;	/* offset btw wolrd origin and the hz pivot */
  dft->y_pivot_offset = 0.0;
  dft->z_pivot_offset = 0.0;
  dft->toe_r = 0.0;		/* toe in for the right eye */
  dft->toe_l = 0.0;		/* toe in for the left eye */
  dft->h_theta_Rpixel = 0.0;	/* field of view per pixel */  
  dft->h_theta_Lpixel = 0.0;
  dft->v_theta_Rpixel = 0.0; 
  dft->v_theta_Lpixel = 0.0;

  dft->out_width = 0;		/* desired image output size */
  dft->out_height = 0;
  dft->universe_radius = 30.0;  /* radius of outer boundary of universe [m] */
  dft->ground_plane = -1.0;  	/* radius of outer boundary of universe [m] */
  dft->sky_billboard_elevation = 3.0; // Angle (deg.) above which to
				      // place everything on billboard
  dft->sky_brightness_threshold = 0;  // Intensity above which to sky dot on
				// billboard
  dft->rm_h_half_kern = 0;	/* low conf pixel removal kernel half size */
  dft->rm_v_half_kern = 0;
  dft->rm_min_matches = 0;	/* min # of pxls to be matched to keep pxl */
  dft->rm_treshold = 1; /* rm_treshold > disp[n]-disp[m] 
					  pixels are not matching */ 
  dft->smr_treshold = 0;	/* treshold for smooth_range function */
  dft->v_fill_treshold = 0;	/* treshold for the file_hole_vert function */
  dft->h_fill_treshold = 0;	/* treshold for the file_hole_vert function */
  dft->nff_v_step = 10;
  dft->nff_h_step = 10;
  dft->mosaic_v_step = 25;
  dft->mosaic_h_step = 25;
  dft->mosaic_sphere_center_x = 0.0;	// x coord of mosaic sphere center
  dft->mosaic_sphere_center_y = 0.0;	// y coord of mosaic sphere center
  dft->mosaic_sphere_center_z = 0.0;	// z coord of mosaic sphere center
  dft->draw_mosaic_ground_plane = 0; // draw the ground plane for mosaics
  dft->mosaic_ignore_intensity = 0; // ignore black pixels in mosaics
  dft->nff_max_jump = 0;
  dft->nff_2d_map = 0;
  dft->verbose = 1;
  dft->pan_offset = 0.0;	/* offset added to pan/tilt read in header */
  dft->tilt_offset = 0.0;
  dft->altitude_range = 1.0;	/* for the altitude texturing */
  dft->altitude_offset = 0.0;
  dft->altitude_mode = 0;	/* 0 limited 1 periodic */
  dft->alt_top_color = 120.0;
  dft->alt_btm_color = 0;
  dft->texture_cntrst = 1.0;
  dft->x_disp_corr = 0.0;	/* correct small/linear distortion */
  dft->y_disp_corr = 0.0;	/* in disparity map */
  dft->disp_corr_offset = 0.0;
  dft->mosaic = 0;		/* mosaic'ing mode */
  dft->smooth_disp_M = 19;	/* matrix size for disparity smoothing */
  dft->smooth_disp_N = 19;
  dft->Lextend = 0;		/* # of pxl to extrapltd (L/R) the disp map */
  dft->Rextend = 0;
  dft->Textend = 0;
  dft->Bextend = 0;
  dft->Toffset = 0;		/* extrapolated pixel offset */
  dft->Boffset = 0;
  dft->lens_corr2 = 0.0;
  dft->lens_corr1 = 0.0;
  dft->lens_corr0 = 0.0;    
  dft->range_scale = 1.0;	/* model scaling factor */ 
  dft->imp_az_offset = 0.0;	/* offset btwn 0 motor count & cam x axis */
  dft->imp_can_z_offset = 0.0;	/* z offset btwn imp origin and el/az axis */ 
  dft->x_imp_offset = 0.0;	/* offset between imp and lander frame */
  dft->y_imp_offset = 0.0;
  dft->z_imp_offset = 0.0;
  dft->local_level_x = 0.0;	/* quaternion for rotating terrain */
  dft->local_level_y = 0.0;	/* into local level frame */
  dft->local_level_z = 0.0;
  dft->local_level_w = 1.0;
  dft->billboard_on = 1;	/* put the far field pixel on a billboard */
  dft->sky_billboard = 0;	// do place everything higher than a
				// given elev. on billboard
  dft->out_mesh_scale = 1.0;    /* scale factor for the output mesh */
  dft->sub_pxl_treshold = 1.0;	/* set disp treshold limit for valid subpxl */
  dft->mask_low_contrast_treshold=1.0; /* low contrast mask treshold value */
  dft->h_tie_pts = 10;		/* number of tie pt for image alignment */
  dft->v_tie_pts = 10;
  dft->xcorr_treshold = 2.0;
  dft->alignMatrix.h11 = 1.0;  	/* homogenous matrix for linear image align */
  dft->alignMatrix.h12 = 0.0;
  dft->alignMatrix.h13 = 0.0;
  dft->alignMatrix.h21 = 0.0;
  dft->alignMatrix.h22 = 1.0;
  dft->alignMatrix.h23 = 0.0;
  dft->alignMatrix.h31 = 0.0;
  dft->alignMatrix.h32 = 0.0;
  dft->alignMatrix.h33 = 1.0;
  dft->rFct = 1.0;		/* ppm images channel weight factor */
  dft->gFct = 1.0;
  dft->bFct = 1.0;
  dft->align_margin = 10;	/* percentage of tie pts to reject */
  dft->ref_cam = 0;		/* use the right camera as a reference */
  dft->ref_eye = 0;		/* use the right eye as a reference */

  dft->texture_casting_type = 0; /* 0 = fit between Imax and Imin */
  dft->max_gray_in_texture = 4095;
  dft->min_gray_in_texture = 0;
  dft->use_motor_count = 0; /* use the motor count instead of the MIPL value */

  dft->ambiColorRed = 0.2;	/* VRML / IV red ambiant color */
  dft->ambiColorGreen = 0.2;	/* VRML / IV green ambiant color */
  dft->ambiColorBlue = 0.2;	/* VRML / IV blue ambiant  color */
  dft->diffColorRed = 0.8;	/* VRML / IV red diffuse color */
  dft->diffColorGreen = 0.8;	/* VRML / IV green diffuse color */
  dft->diffColorBlue = 0.8;	/* VRML / IV blue diffuse color */
  dft->specColorRed = 0.0;     	/* VRML / IV red specular color */
  dft->specColorGreen = 0.0;	/* VRML / IV green specular color */
  dft->specColorBlue = 0.0;	/* VRML / IV blue specular color */
  dft->emisColorRed = 1.0;	/* VRML / IV red emissive color */
  dft->emisColorGreen = 1.0;	/* VRML / IV green emissive color */
  dft->emisColorBlue = 1.0;	/* VRML / IV blue emissive color */
  dft->shininess = 0.2;		/* VRML / IV model shininess */
  dft->transparency = 0.0;	/* VRML / IV model transarency */
  dft->creaseAngle = 1.5;	/* VRML / IV crease angle */
  dft->shapeType_solid = 1;  	/* VRML / IV back face culling */

  dft->mesh_tolerance = 0.001;	/* tolerance of mesh */
  dft->max_triangles = 500000;	/* maximum number of triangles in the mesh */
  dft->write_texture_switch = 0; /* write the vrml texture switch by default
				    T.rgb, S.rgb, M.rgb, A.rgb */

  dft->dem_spacing = 3.0;		   // The USGS standard is 3 arc secs
					   // or 30 meters
  dft->dem_planet_radius = MOLA_PEDR_EQUATORIAL_RADIUS;	   // Nominal Mars polar radius according to the IAU 2000 standard

  return;
}

/************************************************************************/
/*	             initialize Header Structure            		*/
/************************************************************************/

void init_header_struct(DFT_F *dft, 
                        F_HD *hd, 
                        char *cmd_name, 
                        char *input_file, 
                        char *output_file) {
  hd->in_file = NULL;
  hd->in_file2 = NULL;
  hd->out_file = NULL;
  hd->cmd_name = NULL;
  hd->extention = NULL;
  hd->type = NULL;

  hd->in_file = (char *)malloc (NAME_LENGTH * sizeof(char));
  strcpy (hd->in_file, input_file);

  hd->out_file = (char *)malloc (NAME_LENGTH * sizeof(char));
  strcpy (hd->out_file, output_file);

  hd->cmd_name = (char *)malloc (NAME_LENGTH * sizeof(char));
  strcpy (hd->cmd_name, cmd_name);
  
  hd->width = 0;		/* Image width */
  hd->height = 0;		/* Image height */
  hd->total_height = 0;		/* Height of all the buffer */
  hd->max_gray = 0;		/* Max gray level in the pgm image */
  hd->extention = NULL;		/* type file Extention */
  hd->h_theta_pixel = 0.0;	/* [rad/pixel] horizontaly */
  hd->v_theta_pixel = 0.0; 	/* [rad/pixel] vertically */
  hd->pan = 0.0;		/* pan angle */
  hd->tilt = 0.0;		/* tilt angle */
  hd->hcf = 1.0;		/* horizontal compression factor */
  hd->vcf = 1.0;		/* vertical compression factor */
  hd->h_fov = 0.0;		/* horizontal field of view */
  hd->v_fov = 0.0;		/* vertical field of view */

  if(dft->verbose && 0)
    printf("Header structure initialized succesfully\n");

  return;
} /* init_header_struct */

/************************************************************************/
/*									*/
/*		          read stereo.default				*/
/*									*/
/************************************************************************/

void
read_default_file(DFT_F *dft, TO_DO *execute, const char *filename){
  FILE	*inflow;
  int	end_flag;		/* end of default file flag */
  float	value;
  char	name[BUFFER_SIZE];	/* default value name */
  char	buffer[BUFFER_SIZE];
  int	recognized = 0;		/* equal 1 if the field has been recognized */

  /* open file */
  if ( (inflow = fopen (filename, "r" )) == NULL) {
    fprintf (stderr, "Error: cannot open stereo default file:\n");
    exit(EXIT_FAILURE);
  }  
  fgets (buffer, BUFFER_SIZE, inflow);
  if ((buffer[0] != 'S') && (buffer[1] != 'D') && (buffer[2] != 'F')){
    fprintf (stderr, "Error: input file not a stereo.default file\n");
    exit(EXIT_FAILURE);
  }
  end_flag = 0;

  /* read the values */
  while (end_flag == 0){
    fgets (buffer, BUFFER_SIZE, inflow);
    /* do not scan the comment */
    if (0 == (buffer[0]=='#' || buffer[0]==' ' || buffer[0]=='\n')){
      sscanf (buffer, "%s %f", name, &value);

      if(0 == strcmp(name,"END")){
	end_flag = 1;
      }

#define STREQ(ACK,BLAH) (0 == strcmp(ACK, BLAH))
#define GET_INT(X,Y)		else if (STREQ(name, X)) { dft->Y = (int)value; recognized = 1; }
#define GET_INT_SCALED(X,Y,Z)   else if (STREQ(name, X)) { dft->Y = (int)value Z; recognized = 1; }
#define GET_FLOAT(X,Y) 		else if (STREQ(name, X)) { dft->Y = (float)value; recognized = 1; }
#define GET_FLOAT_SCALED(X,Y,Z) else if (STREQ(name, X)) { dft->Y = (float)value Z; recognized = 1; }
#define GET_TO_DO(X,Y)	 	else if (STREQ(name, X)) { execute->Y = (int)value; recognized = 1; }

      /* for the DFT_F structure */
      GET_INT("VERBOSE", verbose)
	GET_INT("H_KERNEL", h_kern)
	GET_INT("V_KERNEL", v_kern)	
	GET_INT("CORR_MARGIN",corr_margin)
	GET_INT("H_CORR_MAX", h_corr_max)
	GET_INT("H_CORR_MIN", h_corr_min)
	GET_INT("CROP_X_MIN", crop_x_min)
	GET_INT("CROP_X_MAX", crop_x_max)
	GET_INT("CROP_Y_MIN", crop_y_min)
	GET_INT("CROP_Y_MAX", crop_y_max)
	GET_INT("V_CORR_MIN", v_corr_min)
	GET_INT("V_CORR_MAX", v_corr_max)
	GET_INT("OUT_HEIGHT", out_height)
	GET_INT("OUT_WIDTH", out_width)
	GET_INT("AUTO_SET_V_CORR_PARAM", autoSetVCorrParam)
	GET_INT("RM_H_HALF_KERN", rm_h_half_kern)
	GET_INT("RM_V_HALF_KERN", rm_v_half_kern)
	GET_INT("RM_MIN_MATCHES", rm_min_matches)
	GET_INT("RM_TRESHOLD", rm_treshold)
	GET_FLOAT("XCORR_TRESHOLD", xcorr_treshold)
	GET_FLOAT("SMR_TRESHOLD", smr_treshold)
	GET_INT("V_FILL_TRESHOLD", v_fill_treshold)
	GET_INT("H_FILL_TRESHOLD", h_fill_treshold)
	GET_INT("NFF_V_STEP", nff_v_step)
	GET_INT("NFF_H_STEP", nff_h_step)
	GET_INT("MOSAIC_V_STEP", mosaic_v_step)
	GET_INT("MOSAIC_H_STEP", mosaic_h_step)
	GET_INT("DRAW_MOSAIC_GROUND_PLANE", draw_mosaic_ground_plane)
	GET_INT("MOSAIC_IGNORE_INTENSITY", mosaic_ignore_intensity)

	GET_FLOAT("EPHEM_ALIGN_KERNEL_X", ephem_align_kernel_x)
        GET_FLOAT("EPHEM_ALIGN_KERNEL_Y", ephem_align_kernel_y)
	GET_INT("EPHEM_ALIGN_KERNEL_WIDTH", ephem_align_kernel_width)
	GET_INT("EPHEM_ALIGN_KERNEL_HEIGHT",ephem_align_kernel_height)

	GET_INT("NFF_MAX_JUMP", nff_max_jump)
	GET_INT("NFF_2D_MAP", nff_2d_map)
	GET_INT("ALTITUDE_MODE", altitude_mode)
	GET_INT("MOSAIC", mosaic)
	GET_INT("SM_DISP_M",smooth_disp_M)
	GET_INT("SM_DISP_N",smooth_disp_N)
	GET_INT("EXTEND_DISP_L",Lextend)
	GET_INT("EXTEND_DISP_R",Rextend)
	GET_INT("EXTEND_DISP_T",Textend)
	GET_INT("EXTEND_DISP_B",Bextend)
	GET_INT("OFFSET_DISP_T",Toffset)
	GET_INT("OFFSET_DISP_B",Boffset)
	GET_INT("FAR_FIELD_BILLBOARD", billboard_on)
	GET_INT("ALIGN_MARGIN_%_REJECT",align_margin)
	GET_INT("REFERENCE_CAMERA",ref_cam)
	GET_INT("MASTER_EYE",ref_eye)
	GET_INT("MAX_TRIANGLES",max_triangles)
	GET_INT("SHAPE_TYPE_SOLID",shapeType_solid)
	GET_INT("WRITE_TEXTURE_SWITCH", write_texture_switch)
	GET_INT("MAX_GRAY_IN_TEXTURE", max_gray_in_texture)
	GET_INT("MIN_GRAY_IN_TEXTURE", min_gray_in_texture)
	GET_INT("TEXTURE_CASTING_TYPE", texture_casting_type)
	GET_INT("USE_MOTOR_COUNT", use_motor_count)
	GET_INT("DO_SKY_BILLBOARD", sky_billboard)

	GET_INT("USE_CAHV", useCAHV)
	GET_FLOAT_SCALED("TILT_OFFSET", tilt_offset, *M_PI/180.0)
	/* from deg to rad */
	GET_FLOAT_SCALED("PAN_OFFSET", pan_offset, *M_PI/180.0)
	GET_FLOAT_SCALED("BASELINE", baseline, /1000.0)	/* from [mm] to [m] */
	GET_FLOAT("ALTITUDE_RANGE", altitude_range)
	GET_FLOAT("ALTITUDE_OFFSET", altitude_offset)
	/* will need a switch case for filter # */
	GET_FLOAT_SCALED("H_THETA_L_PIXEL", h_theta_Lpixel, /1000.0)
	GET_FLOAT_SCALED("H_THETA_R_PIXEL", h_theta_Rpixel, /1000.0)
	GET_FLOAT_SCALED("V_THETA_L_PIXEL", v_theta_Lpixel, /1000.0)
	GET_FLOAT_SCALED("V_THETA_R_PIXEL", v_theta_Rpixel, /1000.0)
	GET_FLOAT_SCALED("L_TOE_IN_0", toe_l, /1000.0)
	GET_FLOAT_SCALED("R_TOE_IN_0", toe_r, /1000.0)
	GET_FLOAT("UNIVERSE_RADIUS", universe_radius)
	GET_FLOAT("SKY_BILLBOARD_ELEVATION", sky_billboard_elevation)
	GET_INT("SKY_BRIGHTNESS_THRESHOLD", sky_brightness_threshold)

	GET_FLOAT("MOSAIC_SPHERE_CENTER_X", mosaic_sphere_center_x)
	GET_FLOAT("MOSAIC_SPHERE_CENTER_Y", mosaic_sphere_center_y)
	GET_FLOAT("MOSAIC_SPHERE_CENTER_Z", mosaic_sphere_center_z)
	GET_FLOAT("GROUND_PLANE_LEVEL", ground_plane)

	GET_FLOAT("X_OFFSET", x_pivot_offset)
	GET_FLOAT("Y_OFFSET", y_pivot_offset)
	GET_FLOAT("Z_OFFSET", z_pivot_offset)
	GET_FLOAT_SCALED("TILT_PIVOT_OFFSET", tilt_pivot_offset, /1000.0)
	GET_FLOAT_SCALED("CAMERA_OFFSET", camera_offset, /1000.0)
	GET_FLOAT("X_DISP_CORRECTION", x_disp_corr)
	GET_FLOAT("Y_DISP_CORRECTION", y_disp_corr)
	GET_FLOAT("DISP_CORR_OFFSET", disp_corr_offset)
	GET_FLOAT("ALT_TOP_COLOR", alt_top_color)
	GET_FLOAT("ALT_BOTTOM_COLOR", alt_btm_color)
	GET_FLOAT("TEXTURE_CONTRAST", texture_cntrst)
	GET_FLOAT("A2", lens_corr2)
	GET_FLOAT("A1", lens_corr1)
	GET_FLOAT("A0", lens_corr0)
	  
	GET_FLOAT("MODEL_SCALE", range_scale)
	GET_FLOAT("IMP_AZ_OFFSET", imp_az_offset)
	GET_FLOAT("IMP_CAN_Z_OFFSET", imp_can_z_offset)
	GET_FLOAT("X_IMP_OFFSET", x_imp_offset)
	GET_FLOAT("Y_IMP_OFFSET", y_imp_offset)
	GET_FLOAT("Z_IMP_OFFSET", z_imp_offset)
	GET_FLOAT("LOCAL_LEVEL_X", local_level_x)
	GET_FLOAT("LOCAL_LEVEL_Y", local_level_y)
	GET_FLOAT("LOCAL_LEVEL_Z", local_level_z)
	GET_FLOAT("LOCAL_LEVEL_W", local_level_w)
	GET_FLOAT("OUT_MESH_SCALE", out_mesh_scale)
	GET_FLOAT("SUB_PXL_TRESHOLD", sub_pxl_treshold)
	GET_FLOAT("MASK_LOW_CONTRAST_TRESHOLD",mask_low_contrast_treshold)
	GET_INT("H_TIE_PTS",h_tie_pts) 
	GET_INT("V_TIE_PTS",v_tie_pts)           
	GET_FLOAT("ALIGN.h11",alignMatrix.h11)           
	GET_FLOAT("ALIGN.h12",alignMatrix.h12)
	GET_FLOAT("ALIGN.h13",alignMatrix.h13)
	GET_FLOAT("ALIGN.h21",alignMatrix.h21)
	GET_FLOAT("ALIGN.h22",alignMatrix.h22)
	GET_FLOAT("ALIGN.h23",alignMatrix.h23)
	GET_FLOAT("ALIGN.h31",alignMatrix.h31)
	GET_FLOAT("ALIGN.h32",alignMatrix.h32)
	GET_FLOAT("ALIGN.h33",alignMatrix.h33)
	GET_FLOAT("RED_CHANEL_FACTOR",rFct)
	GET_FLOAT("GREEN_CHANEL_FACTOR",gFct)
	GET_FLOAT("BLUE_CHANEL_FACTOR",bFct)
	GET_FLOAT("SLOG_KERNEL_WIDTH",slogW)

	GET_FLOAT("AMBIENT_RED",ambiColorRed)
	GET_FLOAT("AMBIENT_GREEN",ambiColorGreen)
	GET_FLOAT("AMBIENT_BLUE",ambiColorBlue)
	GET_FLOAT("DIFFUSE_RED",diffColorRed)
	GET_FLOAT("DIFFUSE_GREEN",diffColorGreen)
	GET_FLOAT("DIFFUSE_BLUE",diffColorBlue)
	GET_FLOAT("SPECULAR_RED",specColorRed)
	GET_FLOAT("SPECULAR_GREEN",specColorGreen)
	GET_FLOAT("SPECULAR_BLUE",specColorBlue)
	GET_FLOAT("EMISSIVE_RED",emisColorRed)
	GET_FLOAT("EMISSIVE_GREEN",emisColorGreen)
	GET_FLOAT("EMISSIVE_BLUE",emisColorBlue)
	GET_FLOAT("SHININESS",shininess)
	GET_FLOAT("TRANSPARENCY",transparency)
	GET_FLOAT("CREASE_ANGLE",creaseAngle)
	GET_FLOAT("MESH_TOLERANCE",mesh_tolerance)
	GET_FLOAT("DEM_SPACING", dem_spacing)
	GET_FLOAT("DEM_PLANET_RADIUS", dem_planet_radius)

	/* For the TO_DO structure */
	GET_TO_DO("DO_ALIGNMENT", do_alignment)
	GET_TO_DO("DO_KEYPOINT_ALIGNMENT", keypoint_alignment)
	GET_TO_DO("DO_EPHEMERIS_ALIGNMENT", ephemeris_alignment)
	GET_TO_DO("DO_EPIPOLAR_ALIGNMENT", epipolar_alignment)

	GET_TO_DO("DO_FORMAT_IMG_SIZE", format_size)
	GET_TO_DO("WRITE_EXTRAPOLATION_MASK", w_extrapolation_mask)
	GET_TO_DO("DO_SLOG", slog)
	GET_TO_DO("DO_LOG", log)
	GET_TO_DO("DO_FIRST_HIST_EQ", eq_hist1)
	GET_TO_DO("DO_EMBOSS", emboss)
	GET_TO_DO("DO_SECOND_HIST_EQ", eq_hist2)
	GET_TO_DO("AUTO_SET_H_CORR_PARAM", autoSetCorrParam)
	GET_TO_DO("DO_VERT_CAL", vert_cal)
	GET_TO_DO("WRITE_PREPROCESSED", w_preprocessed)
	GET_TO_DO("WRITE_TEXTURE", w_texture)
	GET_TO_DO("2D_CORRELATION", biDimCorr)
	GET_TO_DO("CORR_CLEAN_UP", corr_clean_up)
	GET_TO_DO("WRITE_DEBUG_DISP", w_debug_disp)
	GET_TO_DO("WRITE_DISP_STP", w_disp_stp)
	GET_TO_DO("WRITE_DISP_PGM", w_disp_pgm)
	GET_TO_DO("WRITE_DISP_VICAR", w_disp_vicar)

	GET_TO_DO("WRITE_PGM_DISPARITIES", w_pgm_disparity_map)
	GET_TO_DO("WRITE_RAW_DISPARITIES", w_raw_disparity_map)

	GET_TO_DO("FILL_HOLES_NURBS", fill_holes_NURBS)
	GET_TO_DO("FILL_V_HOLES", fill_v_holes)
	GET_TO_DO("FILL_H_HOLES", fill_h_holes)
	GET_TO_DO("FILL_H_HOLES", fill_h_holes)
	GET_TO_DO("EXTEND_DISP_LR", extend_lr)
	GET_TO_DO("EXTEND_DISP_TB", extend_tb)
	GET_TO_DO("SMOOTH_DISP", smooth_disp)
	GET_TO_DO("WRITE_FILTERED_DISP_PGM", w_filtered_disp_pgm)
	GET_TO_DO("SMOOTH_RANGE", smooth_range)
	GET_TO_DO("DO_DOTCLOUD", dotcloud)
	GET_TO_DO("DO_LOCAL_LEVEL_TRANSFORM", local_level_transform)
	GET_TO_DO("WRITE_DOTCLOUD", w_dotcloud)
	GET_TO_DO("WRITE_MVACS_RANGE", w_vicar_range_maps)
	GET_TO_DO("WRITE_VICAR_XYZ", w_vicar_xyz_map)
	GET_TO_DO("DO_3D_MESH", mesh)
	GET_TO_DO("ADAPTIVE_MESHING", adaptative_meshing)
	GET_TO_DO("NFF_PLAIN", nff_plain)
	GET_TO_DO("NFF_TXT", nff_txt)
	GET_TO_DO("DOUBLE_SIDED", double_sided)
	GET_TO_DO("INVENTOR", inventor)
	GET_TO_DO("VRML", vrml)
	GET_TO_DO("WRITE_DEM", write_dem)
	GET_TO_DO("DO_ALTITUDE_TEXTURE", alt_texture)
	GET_TO_DO("APPLY_MASK", apply_mask)
	GET_TO_DO("WRITE_MASK", w_mask)


#undef GET_FLOAT
#undef GET_INT
#undef GET_TO_DO

	if(dft->verbose >=2 && recognized){
	  if(strcmp(name,"END") && 1)
	    printf("%s=%g  ", name, value);
	}
      recognized = 0;
    }
  }
  if(dft->verbose >=2)
    printf("\n");
  if(dft->verbose){
    printf(" *************************************************************\n");
    printf("Stereo Default File loaded successfully\n");
  }
  fclose (inflow);
  return;
} /* read_default_file() */



/*******/
/* END */
/*******/
