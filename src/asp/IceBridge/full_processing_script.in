#!/usr/bin/env python
# __BEGIN_LICENSE__
#  Copyright (c) 2009-2013, United States Government as represented by the
#  Administrator of the National Aeronautics and Space Administration. All
#  rights reserved.
#
#  The NGT platform is licensed under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance with the
#  License. You may obtain a copy of the License at
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# __END_LICENSE__

# Fetch all the data for a run and then process all the data.

import os, sys, optparse, datetime, time, subprocess
import icebridge_common
import fetch_icebridge_data
import process_icebridge_run
import extract_icebridge_ATM_points

# The path to the ASP python files
basepath    = os.path.abspath(sys.path[0])
pythonpath  = os.path.abspath(basepath + '/../IceBridge')  # for dev ASP
pythonpath  = os.path.abspath(basepath + '/../Python')     # for dev ASP
libexecpath = os.path.abspath(basepath + '/../libexec')    # for packaged ASP
sys.path.insert(0, basepath) # prepend to Python path
sys.path.insert(0, pythonpath)
sys.path.insert(0, libexecpath)

import asp_system_utils, asp_alg_utils, asp_geo_utils
asp_system_utils.verify_python_version_is_supported()

# Prepend to system PATH
os.environ["PATH"] = libexecpath + os.pathsep + os.environ["PATH"]
os.environ["PATH"] = basepath    + os.pathsep + os.environ["PATH"]



def fetchAllRunData(yyyymmdd, site, outputFolder,
                    jpegFolder, orthoFolder, demFolder, lidarFolder):
    '''Download all data needed to process a run'''
    
    print 'Downloading all data for the run!  This could take a while...'
    
    # TODO: Provide options for this
    frameStart = 350
    frameStop  = 360
    
    baseCommand = (('--yyyymmdd %s --site %s --frame %d --frame-stop %d')
                   % (yyyymmdd, site, frameStart, frameStop))
    jpegCommand  = '--type image ' + baseCommand +' '+ jpegFolder
    orthoCommand = '--type ortho ' + baseCommand +' '+ orthoFolder
    demCommand   = '--type dem   ' + baseCommand +' '+ demFolder
    lidarCommand = '--type lidar ' + baseCommand +' '+ lidarFolder
    
    # TODO: Handle runs without DEM or ORTHO data.
    
    # Try to do all the downloads one after another
    # - On a failure the error message should already be printed.
    # - The fetching tool will not redownload existing data.
    if fetch_icebridge_data.main(jpegCommand.split()) < 0:
        return -1
    if fetch_icebridge_data.main(orthoCommand.split()) < 0:
        return -1
    if fetch_icebridge_data.main(demCommand.split()) < 0:
        print 'DEM data is optional, continuing run.'
    if fetch_icebridge_data.main(lidarCommand.split()) < 0:
        return -1

    return (jpegFolder, orthoFolder, demFolder, lidarFolder)

def getJpegDateTime(filepath):
    '''Get the date and time from a raw jpeg file.'''
    
    # TODO: For some files it is probably in the name.
    
    # Use this tool to extract the metadata
    cmd      = ['gdalinfo', filepath]
    p        = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = p.communicate()
    
    lines = out.split('\n')

    for line in lines:
        if 'EXIF_DateTimeOriginal' not in line:
            continue
        parts = line.replace('=',' ').split()
        dateString = parts[1].strip().replace(':','')
        timeString = parts[2].strip().replace(':','')
        
        return (dateString, timeString)


    raise Exception('Failed to read date/time from file: ' + filepath)

def convertJpegs(jpegFolder, imageFolder):
    '''Convert jpeg images from RGB to single channel'''

    print 'Converting input images to grayscale...'

    # Loop through all the input images
    os.system('mkdir -p ' + imageFolder)
    jpegFiles = os.listdir(jpegFolder)
    for jpegFile in jpegFiles:
        
        inputPath = os.path.join(jpegFolder, jpegFile)
        
        # Skip non-image files
        ext = os.path.splitext(jpegFile)[1]
        if ext != '.JPG':
            continue
        
        # Make sure the timestamp and frame number are in the output file name
        (dateStr, timeStr) = getJpegDateTime(inputPath)
        frameNumber = icebridge_common.getFrameNumberFromFilename(inputPath)
        outputName = ('DMS_%s_%s_%05d.tif') % (dateStr, timeStr, frameNumber)
        outputPath = os.path.join(imageFolder, outputName)
        
        # Skip existing files
        if os.path.exists(outputPath):
            continue
        
        # Use ImageMagick tool to convert from RGB to grayscale
        cmd = (('convert %s -colorspace Gray %s') % (inputPath, outputPath))
        print cmd
        os.system(cmd)
        if not os.path.exists(outputPath):
            raise Exception('Failed to convert jpeg file: ' + jpegFile)

def getCameraModelsFromOrtho(imageFolder, orthoFolder, inputCamFile, cameraFolder):
    '''Generate camera models from the ortho files'''
    
    print 'Generating camera models from ortho images...'

    # TODO: DEM/height options for this tool
    # TODO: Use multiprocessing for this step?
    
    imageFiles = os.listdir(imageFolder)
    orthoFiles = os.listdir(orthoFolder)
    
    # Make a dictionary of ortho files by frame
    orthoFrames = {}
    for f in orthoFiles:
        # Skip non-image files
        ext = os.path.splitext(f)[1]
        if ext != '.tif':
            continue
        frame = icebridge_common.getFrameNumberFromFilename(f)
        orthoFrames[frame] = f

    # Loop through all input images
    for imageFile in imageFiles:
        
        # Skip non-image files
        ext = os.path.splitext(imageFile)[1]
        if ext != '.tif':
            continue
        
        # Get associated orthofile
        frame     = icebridge_common.getFrameNumberFromFilename(imageFile)       
        orthoFile = orthoFrames[frame]
        
        # Check output file
        inputPath     = os.path.join(imageFolder, imageFile)
        orthoPath     = os.path.join(orthoFolder, orthoFile)
        outputCamFile = os.path.join(cameraFolder, icebridge_common.getCameraFileName(imageFile))
        if os.path.exists(outputCamFile):
            continue
               
        # Call ortho2pinhole command
        cmd = (('/home/smcmich1/repo/StereoPipeline/src/asp/IceBridge/ortho2pinhole %s %s %s %s') % (inputPath, orthoPath, inputCamFile, outputCamFile))
        print cmd
        os.system(cmd)
        if not os.path.exists(outputCamFile):
            raise Exception('Failed to convert ortho file: ' + orthoFile)
            
        # TODO: Clean up the .gcp files?

def convertLidarData(lidarFolder):
    '''Make sure all lidar data is available in a readable text format'''

    print 'Converting LIDAR files...'
    
    # Loop through all lidar files in the folder
    lidarFiles = os.listdir(lidarFolder)
    for f in lidarFiles:
        extension = os.path.splitext(f)[1]
        
        # Only interested in .hdf5 and .qi files
        if (extension != '.qi') and (extension != '.hdf5'):
           continue

        # Handle paths
        fullPath   = os.path.join(lidarFolder, f)
        outputPath = os.path.join(lidarFolder, os.path.splitext(f)[0]+'.csv')
        if os.path.exists(outputPath):
            continue
        
        # Call the conversion
        extract_icebridge_ATM_points.main([fullPath])
        if not os.path.exists(outputPath):
            raise Exception('Failed to parse LIDAR file: ' + fullPath)

def processTheRun(imageFolder, cameraFolder, lidarFolder, processFolder, isSouth, 
                  bundleLength, numProcesses, numThreads):
    '''Do all the run processing'''

    processCommand = (('%s %s %s %s --bundle-length %d --stereo-algorithm 1 --num-processes %d --num-threads %d --pc-align --start-frame 353 --stop-frame 353')
                      % (imageFolder, cameraFolder, lidarFolder, processFolder, bundleLength, numProcesses, numThreads))
    if isSouth:
        processCommand += ' --south'
        
    print processCommand
    process_icebridge_run.main(processCommand.split())
    
def main(argsIn):

    try:
        usage = '''usage: full_processing_script.py <output_folder> <camera_file>

  [ASP [@]ASP_VERSION[@]]'''
                      
        parser = optparse.OptionParser(usage=usage)

        # TODO: Add options to allow spreading work across supercomputer nodes


        # Run selection
        parser.add_option("--yyyymmdd",  dest="yyyymmdd", default=None,
                          help="Specify the year, month, and day in one YYMMDD string.")
        parser.add_option("--site",  dest="site", default=None,
                          help="Name of the location of the images (AN or GR)")

        # Processing options
        parser.add_option('--bundle-length', dest='bundleLength', default=2,
                          type='int', help='The number of images to bundle adjust and process in a single batch.')

        # Performance options  
        parser.add_option('--num-processes', dest='numProcesses', default=1,
                          type='int', help='The number of simultaneous processes to run.')
        parser.add_option('--num-threads', dest='numThreads', default=1,
                          type='int', help='The number of threads per process.')

        # Action control
        parser.add_option("--fetch-only", action="store_true", dest="fetchOnly", default=False,
                          help="Just fetch the data, don't do any processing.")
        parser.add_option("--skip-fetch", action="store_true", dest="noFetch", default=False,
                          help="Skip data fetching.")
        parser.add_option("--skip-convert", action="store_true", dest="noConvert", default=False,
                          help="Skip data conversion.")
        parser.add_option("--stop-after-fetch", action="store_true", dest="stopAfterFetch", default=False,
                          help="Stop program after data fetching.")
        parser.add_option("--stop-after-convert", action="store_true", dest="stopAfterConvert", default=False,
                          help="Stop program after data conversion.")
                          
        (options, args) = parser.parse_args(argsIn)

        if len(args) != 2:
            print usage
            return -1
        
        outputFolder = os.path.abspath(args[0])
        cameraFile   = os.path.abspath(args[1])

    except optparse.OptionError, msg:
        raise Usage(msg)

    # Set up the output folders
    cameraFolder  = os.path.join(outputFolder, 'camera')
    imageFolder   = os.path.join(outputFolder, 'image')
    jpegFolder    = os.path.join(outputFolder, 'jpeg')
    orthoFolder   = os.path.join(outputFolder, 'ortho')
    demFolder     = os.path.join(outputFolder, 'fireball')
    lidarFolder   = os.path.join(outputFolder, 'lidar')
    processFolder = os.path.join(outputFolder, 'processed')

    if not options.noFetch:

        # Call data fetch routine and check the result
        fetchResult = fetchAllRunData(options.yyyymmdd, options.site, outputFolder,
                                      jpegFolder, orthoFolder, demFolder, lidarFolder)
        if fetchResult == -1:
            return -1
        
    if options.stopAfterFetch:
        print 'Fetching complete, finished!'
        return 0

    if not options.noConvert:        
        convertJpegs(jpegFolder, imageFolder)
        
        # TODO: Handle case where orthofiles are not present!
        # TODO: What arguments need to be passed in here!
        getCameraModelsFromOrtho(imageFolder, orthoFolder, cameraFile, cameraFolder)
       
        convertLidarData(lidarFolder)

    if options.stopAfterConvert:
        print 'Conversion complete, finished!'
        return 0
    
    isSouth = (options.site == 'AN')

    # TODO: Add more options!
    # Call the processing routine
    processTheRun(imageFolder, cameraFolder, lidarFolder, processFolder, isSouth,
                  options.bundleLength, options.numProcesses, options.numThreads)

   

# Run main function if file used from shell
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))


