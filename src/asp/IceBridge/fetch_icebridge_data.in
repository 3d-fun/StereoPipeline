#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __BEGIN_LICENSE__
#  Copyright (c) 2009-2013, United States Government as represented by the
#  Administrator of the National Aeronautics and Space Administration. All
#  rights reserved.
#
#  The NGT platform is licensed under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance with the
#  License. You may obtain a copy of the License at
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# __END_LICENSE__

'''
Tool for downloading IceBridge data
'''

import sys, os, re, subprocess, optparse

#------------------------------------------------------------------------------


def getIndexFileName(fileType):
    '''Choose the name of the downloaded index file'''
   
    if fileType == 'image':
        return 'jpeg_index.html'
    if fileType == 'ortho':
        return 'ortho_index.html'
    if fileType == 'dem':
        return 'dem_index.html'

def makeYearFolder(year, site):
    '''Generate part of the URL.  Only used for images.'''
    return str(year) + '_' + site + '_NASA'

def makeDateFolder(year, month, day, fileType):
    '''Generate part of the URL.'''

    if fileType == 'image':
        datePart = ('%02d%02d%04d') % (month, day, year)
        return datePart +'_raw'
    if fileType == 'ortho':
        datePart = ('%04d.%02d.%02d') % (year, month, day)
        return datePart
    if fileType == 'dem':
        datePart = ('%04d.%02d.%02d') % (year, month, day)
        return datePart

#def makeFileName(year, month, day, frame, fileType):
#    
#    datePart = ('%04d_%02d_%02d_%05d') % (year, month, day, frame)
#    if fileType == 'image':
#        ext = 'JPG'
#    if fileType == 'ortho':
#        ext = 'tif' # TODO
#    if fileType == 'dem':
#        ext = 'tif' # TODO 
#    return datePart +'.'+ ext

def getFolderUrl(year, month, day, site, fileType):
    '''Get full URL to the location where the files are kept.'''
    
    if fileType == 'image':
        base = 'https://n5eil01u.ecs.nsidc.org/ICEBRIDGE_FTP/IODMS0_DMSraw_v01'
        yearFolder = makeYearFolder(year, site)
        dateFolder = makeDateFolder(year, month, day, fileType)
        folderUrl  = os.path.join(base, yearFolder, dateFolder)
    if fileType == 'ortho':
        base = 'https://n5eil01u.ecs.nsidc.org/ICEBRIDGE/IODMS1B.001'
        dateFolder = makeDateFolder(year, month, day, fileType)
        folderUrl  = os.path.join(base, dateFolder)
    if fileType == 'dem':
        base = 'https://n5eil01u.ecs.nsidc.org/ICEBRIDGE/IODMS3.001'
        dateFolder = makeDateFolder(year, month, day, fileType)
        folderUrl  = os.path.join(base, dateFolder)
    return folderUrl


def fileExists(path):
    '''Make sure file exists and is non-empty'''
    return os.path.exists(path) and (os.path.getsize(path) > 0)

def fetchAndParseIndexFile(folderUrl, path, parsedPath, fileType):
    '''Retrieve the index file for a folder of data and create
    a parsed version of it that contains frame number / filename pairs.'''

    # Set up the command
    cookiePaths = ' -b ~/.urs_cookies -c ~/.urs_cookies '
    curlOpts    = ' -n -L '
    cmd = 'curl ' + cookiePaths + curlOpts + folderUrl + ' > ' + path

    # Download the file
    print cmd
    p = subprocess.Popen(cmd, shell=True)
    os.waitpid(p.pid, 0)
    
    # Find all the file names in the index file and
    #  dump them to a new index file
    print 'Extracting file name list from index.html file...'
    with open(path, 'r') as f:
        indexText = f.read()
    
    # Extract just the file names
    if fileType == 'image':
        fileList = re.findall(">[0-9_]*.JPG", indexText)
    if fileType == 'ortho':
        fileList = re.findall(">DMS_[0-9_]*.tif<", indexText)
    if fileType == 'dem':
        fileList = re.findall(">IODMS[0-9_]*_DEM.tif", indexText)
    
    # For each entry that matched the regex, record: the "frame" number, the file name.
    with open(parsedPath, 'w') as f:
        for x in fileList:
            if fileType == 'image':
                f.write(x[12:17] +', '+ x[1:] + '\n')
            if fileType == 'ortho':
                f.write(x[13:18] +', '+ x[1:-1] + '\n')
            if fileType == 'dem':
                f.write(x[26:31] +', '+ x[1:] + '\n')


def main(argsIn):

    # Command line parsing
    try:
        usage  = "usage: fetch_icebridge_data.py [options] output_prefix"
        parser = optparse.OptionParser(usage=usage)

        parser.add_option("--year",  dest="year", type='int', default=None,
                          help="Number of processes to use (default program tries to choose best)")
        parser.add_option("--month",  dest="month", type='int', default=None,
                          help="Number of processes to use (default program tries to choose best)")
        parser.add_option("--day",  dest="day", type='int', default=None,
                          help="Number of processes to use (default program tries to choose best)")
        parser.add_option("--yyyymmdd",  dest="yyyymmdd", default=None,
                          help="Specify the year, month, and day in one YYMMDD string.")
        parser.add_option("--site",  dest="site", default=None,
                          help="Name of the location of the images (AN or GR)")
        
        parser.add_option("--frame",  dest="frame", type='int', default=None,
                          help="Frame number or start of frame sequence")
        parser.add_option("--frame-stop",  dest="frameStop", type='int', default=None,
                          help="End of frame sequence to download.")
        parser.add_option("--all-frames", action="store_true", dest="allFrames", default=False,
                          help="Fetch all frames for this flight.")
        
        parser.add_option("--dry-run", action="store_true", dest="dryRun", default=False,
                          help="Just print the image/ortho/dem download commands.")
        
        parser.add_option("--refetch-index", action="store_true", dest="refetchIndex", default=False,
                          help="Force refetch of the index file.")

        parser.add_option("--type",  dest="type", default='image',
                          help="File type to download ([image], ortho, dem)")

        # This call handles all the parallel_mapproject specific options.
        (options, args) = parser.parse_args(argsIn)

        if len(args) == 0:
            print usage
            return -1
        outputPrefix = args[0]
        outputFolder = os.path.dirname(outputPrefix)
        os.system('mkdir -p ' + outputFolder)

        # Handle unified date option
        if options.yyyymmdd:
            options.year  = int(options.yyyymmdd[0,4])
            options.month = int(options.yyyymmdd[4,6])
            options.day   = int(options.yyyymmdd[6,8])

        if not options.frameStop:
            options.frameStop = options.frame

        # Error checking
        if (not options.year) or (not options.month) or (not options.day):
            print 'Error: year, month, and day must be provided.'
            return -1
        
        # Ortho and DEM files don't need this information to find them.
        if (options.type == 'image') and not (options.site == 'AN' or options.site == 'GR'):
            print 'Error, site must be AN or GR for images.'
            return -1

        if not (options.type == 'image' or options.type== 'ortho' or options.type== 'dem'):
            print 'Error, type must be image, ortho, or dem'
            return -1

    except optparse.OptionError, msg:
        raise Exception(msg)

    # This URL contains all of the files
    folderUrl = getFolderUrl(options.year, options.month, options.day, options.site, options.type)
    
    # Fetch the index for this folder
    filename        = getIndexFileName(options.type)
    indexPath       = outputPrefix + filename
    parsedIndexPath = indexPath + '.csv'
    if options.refetchIndex:
        os.system('rm -f ' + indexPath)
        os.system('rm -f ' + parsedIndexPath)
    if fileExists(indexPath):
        print 'Already have the index file ' + indexPath + ', keeping it.'
    else:
        fetchAndParseIndexFile(folderUrl, indexPath, parsedIndexPath, options.type)
    
    # Store file information in a dictionary
    # - Keep track of the earliest and latest frame
    print 'Reading file list...'
    frameDict = {}
    firstFrame = 99999999999
    lastFrame  = 0
    with open(parsedIndexPath, 'r') as f:
        for line in f:
            parts       = line.strip().split(',')
            frameNumber = int(parts[0])
            frameDict[frameNumber] = parts[1].strip()
            if frameNumber < firstFrame:
                firstFrame = frameNumber
            if frameNumber > lastFrame:
                lastFrame = frameNumber

    #print frameDict
    #raise Exception('DEBUG')
    
    if options.allFrames:
        options.frame     = firstFrame
        options.frameStop = lastFrame
    
    if ((options.frame not in frameDict) or
        (options.frameStop and options.frameStop not in frameDict) ):
        print ('Error: Requested frame(s) not found in this flight.\n'+
               'First available frame is: ' + str(firstFrame)+'.\n'+
               'Last  available frame is: ' + str(lastFrame )+'.\n')
        return -1
    
    for frame in range(options.frame, options.frameStop+1):
       
        # Verify that this frame exists in the index file
        
        #filename   = makeFileName(options.year, options.month, options.day, frame, options.type)
        filename   = frameDict[frame]
        url        = os.path.join(folderUrl, filename)
        outputPath = outputPrefix + filename
        
        if fileExists(outputPath):
            print 'File ' + outputPath + ' already exists, skipping it.'
        else:
            # Set up the command
            cookiePaths = ' --load-cookies ~/.urs_cookies --save-cookies ~/.urs_cookies '
            wgetOpts    = ' --keep-session-cookies --no-check-certificate --auth-no-challenge=on -r --reject "index.html*" -np -e robots=off '
            cmd = 'wget ' + cookiePaths + wgetOpts + url + ' -O ' + outputPath
        
            # Download the file
            print cmd
            if not options.dryRun:
                os.system(cmd)


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
